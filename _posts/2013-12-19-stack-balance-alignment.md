---
layout: post
title: "堆栈平衡与对齐"
tags: [asm, 理解计算机]
---
{% include JB/setup %}

###调用约定
　　C语言的种种调用约定中，以__cdecl最为常见，本小节以__cdecl约定为切入点，剖析计算机在函数调用过程的细节，主要分析堆栈的状态变化。

　　调用过程主要分以下几个阶段<sup>[【1】](#【1】)</sup>：
#####参数压栈
　　自右向左将参数逐一压栈。在编译过程中，编译器会根据压栈参数所占用的空间大小，生成相应的代码，用于函数返回时释放这段空间。释放空间的本质只是将esp指针加上释放的长度，并不对释放的空间做清空处理。
#####函数调用
　　在本阶段，处理器将执行call指令，具体操作是：将指令寄存器eip压栈，并跳转到被调用函数的起始地址。相当于连续执行了push和jmp指令。
#####处理ebp寄存器
　　ebp作为基址指针寄存器（base pointer<sup>[【2】](#【2】)</sup>），最常见的应用场景便是通过对ebp附加偏移来访问堆栈中的变量。对于一个特定的函数而言，ebp通常是不变的。这一阶段常见的操作是：

    push ebp
    mov ebp, esp
#####分配局部变量空间
　　局部变量存在于堆栈中，这也是为何局部变量的访问往往比全局变量更快的原因。为局部变量分配空间的操作很简单：

    sub esp, #      ;'#'号表示一个立即数，是局部变量占用总空间的大小
#####保护寄存器状态
　　由于x86架构的CPU只有8个通用寄存器，对于函数间的切调用操作，需要将原先的寄存器状态保存起来，以免调用结束后，调用者的运行异常。

#####执行函数
　　执行函数体。

#####释放局部变量空间
　　。
#####恢复寄存器状态
　　。
#####处理ebp寄存器
　　。
#####函数返回
　　。
#####释放参数空间
　　。
###堆栈对齐
　　。
>　　堆栈对齐

###参考
<span id="【1】"></span>【1】 [http://www.unixwiz.net/techtips/win32-callconv-asm.html](http://www.unixwiz.net/techtips/win32-callconv-asm.html)
<span id="【2】"></span>【2】 [http://www.swansontec.com/sregisters.html](http://www.swansontec.com/sregisters.html)
