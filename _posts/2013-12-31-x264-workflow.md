---
layout: post
title: "x264工作流程【编辑中】"
description: ""
category: ""
tags: [x264, 代码阅读]
---
{% include JB/setup %}

　　本文对x264的编码主要流程进行梳理，涉及到的代码可以在[这里](http://download.videolan.org/pub/videolan/x264/)获取到。

<!--more-->

###使用示例

{% highlight C %}

    x264_param_default_preset(&param, "ultrafast", "zerolatency");
    x264_param_apply_profile(&param, "baseline");
    pCodec->h = x264_encoder_open(&param);

    x264_picture_alloc(&(pCodec->picin), X264_CSP_I420, m_width, m_height);

    x264_encoder_parameters(pCodec->h, &param);

    int headSize = x264_encoder_headers(pCodec->h, &nal_t, &i_nal);
    if (headSize > 0)
    {
        for (int i = 0; i < i_nal; ++i)
        {
            if ((NAL_SPS == nal_t[i].i_type) || (NAL_PPS == nal_t[i].i_type))
            {
                SaveHeader();
            }
        }
    }

    while(1)
    {
        int frameSize = x264_encoder_encode(pCodec->h, &nal_t, &i_nal, pPicin, &m_picout);
        pPicin->i_pts++;
        if (frameSize > 0)
        {
            return SaveVideoCmd(cmd, nal_t, i_nal);
        }
    }

{% endhighlight %}

　　首先是相关参数的初始化和空间的分配，然后是码流头部的编码，接下来就是对每一帧的编码。

　　初始化时，先后对preset和tune进行了设置，此处设置的是最快速编码和零延迟。

{% highlight C %}

    int x264_param_default_preset( x264_param_t *param, const char *preset, const char *tune )
    {
        x264_param_default( param );

        if( preset && x264_param_apply_preset( param, preset ) < 0 )
            return -1;
        if( tune && x264_param_apply_tune( param, tune ) < 0 )
            return -1;
        return 0;
    }

{% endhighlight %}

　　接下来是profile的设置，x264支持main和baseline。

{% highlight C %}

int x264_param_apply_profile( x264_param_t *param, const char *profile )
{
    int p = profile_string_to_int( profile );

    if( p == PROFILE_BASELINE )
    {
        param->analyse.b_transform_8x8 = 0;
        param->b_cabac = 0;
        param->i_cqm_preset = X264_CQM_FLAT;
        param->psz_cqm_file = NULL;
        param->i_bframe = 0;
        param->analyse.i_weighted_pred = X264_WEIGHTP_NONE;
    }
    else if( p == PROFILE_MAIN )
    {
        param->analyse.b_transform_8x8 = 0;
        param->i_cqm_preset = X264_CQM_FLAT;
        param->psz_cqm_file = NULL;
    }
    return 0;
}

{% endhighlight %}

　　然后根据参数打开x264编码器。
{% highlight C %}

x264_t *x264_encoder_open( x264_param_t *param )
{
    /* Create a copy of param */
    memcpy( &h->param, param, sizeof(x264_param_t) );

    x264_threading_init();
    x264_validate_parameters( h, 1 );
    x264_cqm_parse_file( h, h->param.psz_cqm_file );

    h->param.rc.psz_stat_out = strdup( h->param.rc.psz_stat_out );
    h->param.rc.psz_stat_in = strdup( h->param.rc.psz_stat_in );

    x264_reduce_fraction( &h->param.i_fps_num, &h->param.i_fps_den );
    x264_reduce_fraction( &h->param.i_timebase_num, &h->param.i_timebase_den );

    /* Init x264_t */
    x264_sps_init( h->sps, h->param.i_sps_id, &h->param );
    x264_pps_init( h->pps, h->param.i_sps_id, &h->param, h->sps );
    x264_set_aspect_ratio( h, &h->param, 1 );
    x264_validate_levels( h, 1 );
    x264_cqm_init( h );
    x264_rdo_init();

    /* init CPU functions */
    x264_predict_16x16_init( h->param.cpu, h->predict_16x16 );
    x264_predict_8x8c_init( h->param.cpu, h->predict_8x8c );
    x264_predict_8x16c_init( h->param.cpu, h->predict_8x16c );
    x264_predict_8x8_init( h->param.cpu, h->predict_8x8, &h->predict_8x8_filter );
    x264_predict_4x4_init( h->param.cpu, h->predict_4x4 );
    x264_pixel_init( h->param.cpu, &h->pixf );
    x264_dct_init( h->param.cpu, &h->dctf );
    x264_zigzag_init( h->param.cpu, &h->zigzagf_progressive, &h->zigzagf_interlaced );
    x264_mc_init( h->param.cpu, &h->mc, h->param.b_cpu_independent );
    x264_quant_init( h, h->param.cpu, &h->quantf );
    x264_deblock_init( h->param.cpu, &h->loopf, PARAM_INTERLACED );
    x264_bitstream_init( h->param.cpu, &h->bsf );
    x264_cabac_init( h );
    mbcmp_init( h );
    chroma_dsp_init( h );


    x264_threadpool_init( &h->threadpool, h->param.i_threads, (void*)x264_encoder_thread_init, h );
    x264_threadpool_init( &h->lookaheadpool, h->param.i_lookahead_threads, NULL, NULL );

    for( int i = 0; i < h->param.i_threads; i++ )
    {
        x264_pthread_mutex_init( &h->thread[i]->mutex, NULL );
        x264_pthread_cond_init( &h->thread[i]->cv, NULL );
        h->thread[i]->fdec = x264_frame_pop_unused( h, 1 );
        x264_macroblock_cache_allocate( h->thread[i] );
    }

    x264_lookahead_init( h, i_slicetype_length );

    for( int i = 0; i < h->param.i_threads; i++ )
        x264_macroblock_thread_allocate( h->thread[i], 0 );

    x264_ratecontrol_new( h );

    return h;
}

{% endhighlight %}

　　这一阶段的工作主要是初始化编码器参数，初始化CPU相关函数，初始化线程池和码率控制。

　　接下来是picture的空间申请，只是简单地设置参数和申请空间。然后调用x264_encoder_parameters将此时编码器的参数取出，只是内存拷贝而已。

　　然后开始对码流头部进行编码，传输SPS和PPS。

{% highlight C %}

    int x264_encoder_headers( x264_t *h, x264_nal_t **pp_nal, int *pi_nal )
    {
        /* init bitstream context */
        h->out.i_nal = 0;
        bs_init( &h->out.bs, h->out.p_bitstream, h->out.i_bitstream );
        /* generate sequence parameters */
        x264_nal_start( h, NAL_SPS, NAL_PRIORITY_HIGHEST );
        x264_sps_write( &h->out.bs, h->sps );
        x264_nal_end( h );
        /* generate picture parameters */
        x264_nal_start( h, NAL_PPS, NAL_PRIORITY_HIGHEST );
        x264_pps_write( &h->out.bs, h->sps, h->pps );
        x264_nal_end( h );

        frame_size = x264_encoder_encapsulate_nals( h, 0 );
        /* now set output*/
        *pi_nal = h->out.i_nal;
        *pp_nal = &h->out.nal[0];
        h->out.i_nal = 0;

        return frame_size;
    }

{% endhighlight %}

　　接下来，是最重要的编码功能了。

{% highlight C %}

int     x264_encoder_encode( x264_t *h,
                             x264_nal_t **pp_nal, int *pi_nal,
                             x264_picture_t *pic_in,
                             x264_picture_t *pic_out )
{
    if( h->i_thread_frames > 1 )
    {
        thread_prev    = h->thread[ h->i_thread_phase ];
        h->i_thread_phase = (h->i_thread_phase + 1) % h->i_thread_frames;
        thread_current = h->thread[ h->i_thread_phase ];
        thread_oldest  = h->thread[ (h->i_thread_phase + 1) % h->i_thread_frames ];
        x264_thread_sync_context( thread_current, thread_prev );
        x264_thread_sync_ratecontrol( thread_current, thread_prev, thread_oldest );
        h = thread_current;
    }
    else
        thread_current = thread_oldest = h;
    h->i_cpb_delay_pir_offset = h->i_cpb_delay_pir_offset_next;

    /* no data out */
    *pi_nal = 0;
    *pp_nal = NULL;

    /* ------------------- Setup new frame from picture -------------------- */
    if( pic_in != NULL )
    {
        /* 1: Copy the picture to a frame and move it to a buffer */
        x264_frame_t *fenc = x264_frame_pop_unused( h, 0 );
        x264_frame_copy_picture( h, fenc, pic_in );

        if( h->param.i_width != 16 * h->mb.i_mb_width ||
            h->param.i_height != 16 * h->mb.i_mb_height )
            x264_frame_expand_border_mod16( h, fenc );

        fenc->i_frame = h->frames.i_input++;

        if( fenc->i_frame == 0 )
            h->frames.i_first_pts = fenc->i_pts;
        if( h->frames.i_bframe_delay && fenc->i_frame == h->frames.i_bframe_delay )
            h->frames.i_bframe_delay_time = fenc->i_pts - h->frames.i_first_pts;

        if( h->param.b_vfr_input && fenc->i_pts <= h->frames.i_largest_pts )
            x264_log( h, X264_LOG_WARNING, "non-strictly-monotonic PTS\n" );

        h->frames.i_second_largest_pts = h->frames.i_largest_pts;
        h->frames.i_largest_pts = fenc->i_pts;

        if( h->param.rc.b_mb_tree && h->param.rc.b_stat_read )
            x264_macroblock_tree_read( h, fenc, pic_in->prop.quant_offsets );
        else
            x264_stack_align( x264_adaptive_quant_frame, h, fenc, pic_in->prop.quant_offsets );

        if( pic_in->prop.quant_offsets_free )
            pic_in->prop.quant_offsets_free( pic_in->prop.quant_offsets );

        if( h->frames.b_have_lowres )
            x264_frame_init_lowres( h, fenc );

        /* 2: Place the frame into the queue for its slice type decision */
        x264_lookahead_put_frame( h, fenc );
    }
    else
    {
        /* signal kills for lookahead thread */
        x264_pthread_mutex_lock( &h->lookahead->ifbuf.mutex );
        h->lookahead->b_exit_thread = 1;
        x264_pthread_cond_broadcast( &h->lookahead->ifbuf.cv_fill );
        x264_pthread_mutex_unlock( &h->lookahead->ifbuf.mutex );
    }

    h->i_frame++;
    /* 3: The picture is analyzed in the lookahead */
    if( !h->frames.current[0] )
        x264_lookahead_get_frames( h );

    if( !h->frames.current[0] && x264_lookahead_is_empty( h ) )
        return x264_encoder_frame_end( thread_oldest, thread_current, pp_nal, pi_nal, pic_out );

    /* ------------------- Get frame to be encoded ------------------------- */
    /* 4: get picture to encode */
    h->fenc = x264_frame_shift( h->frames.current );

    /* If applicable, wait for previous frame reconstruction to finish */
    if( h->param.b_sliced_threads )
        x264_threadpool_wait_all( h );

    if( h->fenc->param )
    {
        x264_encoder_reconfig( h, h->fenc->param );
        if( h->fenc->param->param_free )
        {
            h->fenc->param->param_free( h->fenc->param );
            h->fenc->param = NULL;
        }
    }

    // ok to call this before encoding any frames, since the initial values of fdec have b_kept_as_ref=0
    x264_reference_update( h );
    h->fdec->i_lines_completed = -1;

    /* ------------------- Setup frame context ----------------------------- */
    /* 5: Init data dependent of frame type */
    if( h->fenc->i_type == X264_TYPE_IDR )
    {
        /* reset ref pictures */
        i_nal_type    = NAL_SLICE_IDR;
        i_nal_ref_idc = NAL_PRIORITY_HIGHEST;
        h->sh.i_type = SLICE_TYPE_I;
        x264_reference_reset( h );
        h->frames.i_poc_last_open_gop = -1;
    }
    else if( h->fenc->i_type == X264_TYPE_I )
    {
        i_nal_type    = NAL_SLICE;
        i_nal_ref_idc = NAL_PRIORITY_HIGH; /* Not completely true but for now it is (as all I/P are kept as ref)*/
        h->sh.i_type = SLICE_TYPE_I;
        x264_reference_hierarchy_reset( h );
        if( h->param.b_open_gop )
            h->frames.i_poc_last_open_gop = h->fenc->b_keyframe ? h->fenc->i_poc : -1;
    }
    else if( h->fenc->i_type == X264_TYPE_P )
    {
        i_nal_type    = NAL_SLICE;
        i_nal_ref_idc = NAL_PRIORITY_HIGH; /* Not completely true but for now it is (as all I/P are kept as ref)*/
        h->sh.i_type = SLICE_TYPE_P;
        x264_reference_hierarchy_reset( h );
        h->frames.i_poc_last_open_gop = -1;
    }

    /* ------------------- Init                ----------------------------- */
    /* build ref list 0/1 */
    x264_reference_build_list( h, h->fdec->i_poc );

    /* ---------------------- Write the bitstream -------------------------- */
    /* Init bitstream context */
    if( h->param.b_sliced_threads )
    {
        for( int i = 0; i < h->param.i_threads; i++ )
        {
            bs_init( &h->thread[i]->out.bs, h->thread[i]->out.p_bitstream, h->thread[i]->out.i_bitstream );
            h->thread[i]->out.i_nal = 0;
        }
    }
    else
    {
        bs_init( &h->out.bs, h->out.p_bitstream, h->out.i_bitstream );
        h->out.i_nal = 0;
    }

    if( h->param.b_aud )
    {
        int pic_type;

        x264_nal_start( h, NAL_AUD, NAL_PRIORITY_DISPOSABLE );
        bs_write( &h->out.bs, 3, pic_type );
        bs_rbsp_trailing( &h->out.bs );
        x264_nal_end( h );
        overhead += h->out.nal[h->out.i_nal-1].i_payload + NALU_OVERHEAD;
    }

    if( h->fenc->b_keyframe )
    {
        /* Write SPS and PPS */
        if( h->param.b_repeat_headers )
        {
            /* generate sequence parameters */
            x264_nal_start( h, NAL_SPS, NAL_PRIORITY_HIGHEST );
            x264_sps_write( &h->out.bs, h->sps );
            x264_nal_end( h );
            /* Pad AUD/SPS to 256 bytes like Panasonic */
            if( h->param.b_avcintra_compat )
                h->out.nal[h->out.i_nal-1].i_padding = 256 - bs_pos( &h->out.bs ) / 8 - 2*NALU_OVERHEAD;
            overhead += h->out.nal[h->out.i_nal-1].i_payload + h->out.nal[h->out.i_nal-1].i_padding + NALU_OVERHEAD;

            /* generate picture parameters */
            x264_nal_start( h, NAL_PPS, NAL_PRIORITY_HIGHEST );
            x264_pps_write( &h->out.bs, h->sps, h->pps );
            x264_nal_end( h );
            if( h->param.b_avcintra_compat )
                h->out.nal[h->out.i_nal-1].i_padding = 256 - h->out.nal[h->out.i_nal-1].i_payload - NALU_OVERHEAD;
            overhead += h->out.nal[h->out.i_nal-1].i_payload + h->out.nal[h->out.i_nal-1].i_padding + NALU_OVERHEAD;
        }

        /* when frame threading is used, buffering period sei is written in x264_encoder_frame_end */
        if( h->i_thread_frames == 1 && h->sps->vui.b_nal_hrd_parameters_present )
        {
            x264_hrd_fullness( h );
            x264_nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
            x264_sei_buffering_period_write( h, &h->out.bs );
            x264_nal_end( h );
            overhead += h->out.nal[h->out.i_nal-1].i_payload + SEI_OVERHEAD;
        }
    }

    /* generate sei pic timing */
    if( h->sps->vui.b_pic_struct_present || h->sps->vui.b_nal_hrd_parameters_present )
    {
        x264_nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
        x264_sei_pic_timing_write( h, &h->out.bs );
        x264_nal_end( h );
        overhead += h->out.nal[h->out.i_nal-1].i_payload + SEI_OVERHEAD;
    }

    /* As required by Blu-ray. */
    if( !IS_X264_TYPE_B( h->fenc->i_type ) && h->b_sh_backup )
    {
        h->b_sh_backup = 0;
        x264_nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
        x264_sei_dec_ref_pic_marking_write( h, &h->out.bs );
        x264_nal_end( h );
        overhead += h->out.nal[h->out.i_nal-1].i_payload + SEI_OVERHEAD;
    }

    if( h->fenc->b_keyframe && h->param.b_intra_refresh )
        h->i_cpb_delay_pir_offset_next = h->fenc->i_cpb_delay;

    /* Filler space: 10 or 18 SEIs' worth of space, depending on resolution */
    if( h->param.b_avcintra_compat )
    {
        /* Write an empty filler NAL to mimic the AUD in the P2 format*/
        if( h->param.b_avcintra_compat )
        {
            x264_nal_start( h, NAL_FILLER, NAL_PRIORITY_DISPOSABLE );
            x264_filler_write( h, &h->out.bs, 0 );
            x264_nal_end( h );
            overhead += h->out.nal[h->out.i_nal-1].i_payload + NALU_OVERHEAD;
        }

        /* All lengths are magic lengths that decoders expect to see */
        /* "UMID" SEI */
        x264_nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
        x264_sei_avcintra_write( h, &h->out.bs, 497, "UMID" );
        x264_nal_end( h );
        overhead += h->out.nal[h->out.i_nal-1].i_payload + SEI_OVERHEAD;

        /* "VANC" SEI */
        x264_nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
        x264_sei_avcintra_write( h, &h->out.bs, unpadded_len, "VANC" );
        x264_nal_end( h );
    }

    /* Init the rate control */
    /* FIXME: Include slice header bit cost. */
    x264_ratecontrol_start( h, h->fenc->i_qpplus1, overhead*8 );
    i_global_qp = x264_ratecontrol_qp( h );

    if( h->param.rc.b_stat_read && h->sh.i_type != SLICE_TYPE_I )
    {
        x264_reference_build_list_optimal( h );
        x264_reference_check_reorder( h );
    }

    /* ------------------------ Create slice header  ----------------------- */
    x264_slice_init( h, i_nal_type, i_global_qp );

    /*------------------------- Weights -------------------------------------*/
    if( h->sh.i_type == SLICE_TYPE_B )
        x264_macroblock_bipred_init( h );

    x264_weighted_pred_init( h );

    /* Write frame */
    if( h->i_thread_frames > 1 )
    {
        x264_threadpool_run( h->threadpool, (void*)x264_slices_write, h );
        h->b_thread_active = 1;
    }
    x264_slices_write( h );

    return x264_encoder_frame_end( thread_oldest, thread_current, pp_nal, pi_nal, pic_out );
}

{% endhighlight %}
